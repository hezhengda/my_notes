
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Theoretical background of NequIP &#8212; Zhengda&#39;s Library 0.0.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=23995236" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=e645c8fa"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'ML_potential/NequIP_theory';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Practical use of NequIP" href="NequIP_practice.html" />
    <link rel="prev" title="NequIP" href="NequIP.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Zhengda's Library 0.0.1 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../learning_notes/index.html">Learning Notes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../research_notes/index.html">Research Notes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../research_notes/aqueous_stability_mp.html">Aqueous stability of metal and metal (oxy)(hydr)oxides</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">Machine learning potential</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2 current active has-children"><a class="reference internal" href="NequIP.html">NequIP</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l3 current active"><a class="current reference internal" href="#">Theoretical background of NequIP</a></li>
<li class="toctree-l3"><a class="reference internal" href="NequIP_practice.html">Practical use of NequIP</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/ML_potential/NequIP_theory.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Theoretical background of NequIP</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-foundation-of-nequip">Mathematical foundation of NequIP</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#build-a-nequip-network-from-scratch">Build a NequIP network from scratch</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#architecture-of-energy-model-in-nequip">Architecture of energy model in NequIP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#initilization-of-the-features-in-nodes-and-edges">Initilization of the features in nodes and edges</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convolutional-layers">Convolutional Layers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#feed-forward-network-and-global-pooling">Feed-forward network and global pooling</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#check-equivariance-of-the-energy-model">Check equivariance of the energy model</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#several-nice-talks-about-the-theory-of-nequip">Several nice talks about the theory of NequIP</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="theoretical-background-of-nequip">
<h1>Theoretical background of NequIP<a class="headerlink" href="#theoretical-background-of-nequip" title="Link to this heading">#</a></h1>
<p>Any machine learning potential is a mapping from the atomic configurations (<span class="math notranslate nohighlight">\(\{\vec{R}_i\}, \{Z_i\}\)</span>) to the total energy (<span class="math notranslate nohighlight">\(E_{tot}\)</span>) for the system and forces (<span class="math notranslate nohighlight">\(\vec{F}_i\)</span>) for each atom. The goal of machine learning potential is to learn the potential energy surface (PES) from a set of known data (training set), which contains a set of atomic configurations and their corresponding energy, forces and stresses. After training, we can use the learned potential to predict the energy and forces for unseen configurations.</p>
<section id="mathematical-foundation-of-nequip">
<h2>Mathematical foundation of NequIP<a class="headerlink" href="#mathematical-foundation-of-nequip" title="Link to this heading">#</a></h2>
<p><strong>NequIP</strong> is shortened for “Neural Equivariant Interatomic Potential” (<a class="reference external" href="https://www.nature.com/articles/s41467-022-29939-5">original paper</a>). It is a graph neural network (GNN), which maps the atomic structure to a graph, assign features and attributes to atoms and bonds, then use convolutions between nodes and edges to learn representations of the local atomic environments. In the end the features of each atom is used to predict its atomic energy (<span class="math notranslate nohighlight">\(E_i\)</span>), and the total energy of the system is the sum of atomic energies from all atoms (<span class="math notranslate nohighlight">\(E = \sum_{i} E_i\)</span>).</p>
<p>NequIP is an equivariant model, which means for scalars it is invariant to permutations of atoms, and for vectors it is equivariant to permutations of atoms. Equivariance is an important symmetry for multi-dimensional quantities of physical systems, such as forces. When you rotate the system, the total energy of the system shouldn’t change, but the direction of the forces will rotate together with the system. See the example below about how equivariance works.</p>
<figure class="align-center" id="id1">
<a class="reference internal image-reference" href="../_images/equivariant_example.gif"><img alt="../_images/equivariant_example.gif" src="../_images/equivariant_example.gif" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Example of equivariant property of the network. When the image is rotated, the feature is also rotated. The figure comes from <a class="reference external" href="https://www.reddit.com/r/MachineLearning/comments/t2ktdn/r_a_program_to_build_enequivariant_steerable_cnns/">think link</a>.</span><a class="headerlink" href="#id1" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In order to achieve equivariance, NequIP is built on the previous <strong>e3nn</strong> model (<a class="reference external" href="https://arxiv.org/abs/2207.09453">paper</a>, <a class="reference external" href="https://github.com/e3nn/e3nn">git-repo</a>). The features of nodes (atoms) and edges (bonds) are sorted according to the rotation order (<span class="math notranslate nohighlight">\(l\)</span>). The edges (<span class="math notranslate nohighlight">\(\vec{R}_{ij} = \vec{R}_i - \vec{R}_j\)</span>) can be expanded according to spherical harmonics (<span class="math notranslate nohighlight">\(Y_l^m(\vec{R}_{ij})\)</span>):</p>
<div class="math notranslate nohighlight">
\[\vec{R}_{ij} = \sum_{l, m} R_{ij}^{l_e,m_e,p_e} Y_{l_e}^{m_e}(\hat{R}_{ij})\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{R}_{ij}\)</span> is the unit vector of <span class="math notranslate nohighlight">\(\vec{R}_{ij}\)</span> where <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> are the indexes of two atoms, <span class="math notranslate nohighlight">\(R_{ij}^{l_e,m_e,p_e}\)</span> are the rotation equivariant features of edges (e), and <span class="math notranslate nohighlight">\(Y_{l_e}^{m_e}(\hat{R}_{ij})\)</span> are the spherical harmonics. The value of <span class="math notranslate nohighlight">\(l_e\)</span> is from 0 to <span class="math notranslate nohighlight">\(l_{\text{max}}\)</span>, where <span class="math notranslate nohighlight">\(l_{\text{max}}\)</span> is the maximum rotation order we have set. The value of <span class="math notranslate nohighlight">\(m_e\)</span> is from <span class="math notranslate nohighlight">\(-l_e\)</span> to <span class="math notranslate nohighlight">\(l_e\)</span>. <span class="math notranslate nohighlight">\(p_e\)</span> is the parity, which is <span class="math notranslate nohighlight">\(+1\)</span> for even <span class="math notranslate nohighlight">\(l_e\)</span> and <span class="math notranslate nohighlight">\(-1\)</span> for odd <span class="math notranslate nohighlight">\(l_e\)</span>. By adding parity, we ensure the equivariance is in <span class="math notranslate nohighlight">\(\rm O(3)\)</span> group (includes all orthogonal matrices <span class="math notranslate nohighlight">\(Q\rightarrow Q^T = Q^{-1}\)</span>, for which the determinant can be either 1 or -1) rather than just <span class="math notranslate nohighlight">\(\rm SO(3)\)</span> group (which only includes rotation matrices with determinant of 1). For rotation order <span class="math notranslate nohighlight">\(l_e\)</span>, we have <span class="math notranslate nohighlight">\(2l_e+1\)</span> rotational equivariant features (<span class="math notranslate nohighlight">\(R_{ij}^{l_e,m_e,p_e}\)</span>).</p>
<p>The convolution between the features of nodes (denoted as <span class="math notranslate nohighlight">\(V_{icm_n}^{l_n,p_{n}}\)</span>) and its surrounding edges (denoted as <span class="math notranslate nohighlight">\(R_{ij}^{l_e,m_e,p_e}\)</span>) are performed according to the tensor product of their irreducible representations.</p>
<div class="math notranslate nohighlight">
\[\begin{split}V_{icm_o}^{l_o,p_{o}} = \sum_{m_n, m_e}\begin{pmatrix}l_n &amp; l_e &amp; l_o\\m_n &amp; m_e &amp; m_o\end{pmatrix}\sum_{j\in N(i)}R_{ij}^{l_e,m_e,p_e}Y_{l_e}^{m_e}(\hat{R}_{ij})\times V_{jcm_n}^{l_n,p_{n}}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\begin{pmatrix}l_n &amp; l_e &amp; l_o\\m_n &amp; m_e &amp; m_o\end{pmatrix}\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/3-j_symbol">Wigner 3-j symbol</a>, the value of <span class="math notranslate nohighlight">\(l_o\)</span> can choose from: <span class="math notranslate nohighlight">\(|l_n-l_e|\le l_o \le l_n+l_e\)</span>, and <span class="math notranslate nohighlight">\(m_o\)</span> can choose from: <span class="math notranslate nohighlight">\([-l_o,l_o]\)</span>, <span class="math notranslate nohighlight">\(p_o=p_n\times p_e\)</span>. <span class="math notranslate nohighlight">\(N(i)\)</span> is the neighbor of atom <span class="math notranslate nohighlight">\(i\)</span> with certain cutoff radius (<span class="math notranslate nohighlight">\(r_{\text{c}}\)</span>), <span class="math notranslate nohighlight">\(R_{ij}^{l_e,m_e,p_e}\)</span> is the rotational equivariant features of edges, <span class="math notranslate nohighlight">\(V_{jcm_n}^{l_n,p_{n}}\)</span> is the features of neighbor atom <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>In here I’m giving a simple example to show how the convolution works. Suppose we have a node with irreducible representation (shortened as irreps): <span class="math notranslate nohighlight">\(\rm 2x0e+3x1o\)</span>, this means we have 2 <span class="math notranslate nohighlight">\(\rm 0e\)</span> irreps and 3 <span class="math notranslate nohighlight">\(\rm 1o\)</span> irreps. For detailed discussion about irreps, please refer to <a class="reference external" href="https://docs.e3nn.org/en/stable/guide/irreps.html">this link</a>. For the irreps <span class="math notranslate nohighlight">\(\rm 0e\)</span> (this can also be written as <span class="math notranslate nohighlight">\((l=0,p=0)\)</span>), we have 1 element (<span class="math notranslate nohighlight">\(m=0\)</span>); for the irreps <span class="math notranslate nohighlight">\(\rm 1o\)</span> (this can also be written as <span class="math notranslate nohighlight">\((l=1,p=1)\)</span>), we have 3 elements (<span class="math notranslate nohighlight">\(m=-1,0,1\)</span>). Suppose we have the irreps of the edge as <span class="math notranslate nohighlight">\(\rm 1x0e+1x1o\)</span>, during the convolution, if we assume complete tensor product which means we save all the results, then we have:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rm (2x0e)\otimes (0e) = 2x0e\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\rm (2x0e)\otimes (1o) = 2x1o\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\rm (3x1o)\otimes (0e) = 3x1o\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\rm (3x1o)\otimes (1o) = 3x0e+3x1o+3x2e\)</span></p></li>
</ul>
<p>The derivation of above results follows this simple formula: <span class="math notranslate nohighlight">\((a(l_i,p_i))\otimes(b(l_j,p_j))=\sum_{l_o}
\{(a\times b)(l_o,p_o)\}\)</span>, where <span class="math notranslate nohighlight">\(l_o\in [|l_i-l_j|,l_i+l_j]\)</span>, and <span class="math notranslate nohighlight">\(p_o=p_i\times p_j\)</span>. In here the add symbol <span class="math notranslate nohighlight">\(+\)</span> is the direct sum of irreps.</p>
<p>Then we can add the same irreps together and get: <span class="math notranslate nohighlight">\(\rm (2x0e+3x1o)\otimes(1x0e+1x1o)=5x0e+8x1o+3x2e\)</span>. It is clear that after the convolution the number of features increases, which means now the feature vector is more expressive in describing the local atomic environments.</p>
<p>Till now, we have introduced the most important mathematical foundation of NequIP. In the next section, we will disect each component of NequIP in detail.</p>
</section>
<section id="build-a-nequip-network-from-scratch">
<h2>Build a NequIP network from scratch<a class="headerlink" href="#build-a-nequip-network-from-scratch" title="Link to this heading">#</a></h2>
<p>In NequIP, we are using <a class="reference external" href="https://wiki.fysik.dtu.dk/ase/index.html">atomic simulation environment (ASE)</a> to process the atomic structures. So each structure is an ASE <strong>Atoms</strong> object, and we will convert that to an <strong>AtomicData</strong> object (<a class="reference external" href="https://github.com/mir-group/nequip/blob/main/nequip/data/AtomicData.py">definition</a>), but inside the model, they are using <strong>AtomicDataDict</strong> to do all the operations. The list of parameters for <strong>AtomicDataDict</strong> is shown in below. Since both nodes and edges are presented, which means NequIP is a graph neural network (GNN):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">_DEFAULT_LONG_FIELDS</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_INDEX_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">ATOMIC_NUMBERS_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">ATOM_TYPE_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">BATCH_KEY</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># for nodes</span>
<span class="n">_DEFAULT_NODE_FIELDS</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">POSITIONS_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">,</span> <span class="c1"># this is the features of nodes (atoms)</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_ATTRS_KEY</span><span class="p">,</span> <span class="c1"># this is the attributes of nodes (which is not changed during the training)</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">ATOMIC_NUMBERS_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">ATOM_TYPE_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">FORCE_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">PER_ATOM_ENERGY_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">BATCH_KEY</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># for edges</span>
<span class="n">_DEFAULT_EDGE_FIELDS</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_CELL_SHIFT_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_VECTORS_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_LENGTH_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_ATTRS_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_EMBEDDING_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_FEATURES_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_CUTOFF_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_ENERGY_KEY</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># for global graph</span>
<span class="n">_DEFAULT_GRAPH_FIELDS</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">TOTAL_ENERGY_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">STRESS_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">VIRIAL_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">PBC_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">CELL_KEY</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">BATCH_PTR_KEY</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">_DEFAULT_CARTESIAN_TENSOR_FIELDS</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">STRESS_KEY</span><span class="p">:</span> <span class="s2">&quot;ij=ji&quot;</span><span class="p">,</span>
    <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">VIRIAL_KEY</span><span class="p">:</span> <span class="s2">&quot;ij=ji&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="architecture-of-energy-model-in-nequip">
<h3>Architecture of energy model in NequIP<a class="headerlink" href="#architecture-of-energy-model-in-nequip" title="Link to this heading">#</a></h3>
<p><strong>Energy</strong> is the central quantity to predict in NequIP, the model for predicting energy is written in <a class="reference external" href="https://github.com/mir-group/nequip/blob/main/nequip/model/_eng.py">here</a>. The architecture of the model is shown in the below figure.</p>
<figure class="align-center" id="id2">
<span id="nequip-energy"></span><a class="reference internal image-reference" href="../_images/nequip_energy.png"><img alt="../_images/nequip_energy.png" src="../_images/nequip_energy.png" style="width: 400px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Architecture of the energy model in NequIP (copied from Fig. 1 in Nat. Commun., 2022, 13, 2453).</span><a class="headerlink" href="#id2" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>We only need to focus on the <code class="code docutils literal notranslate"><span class="pre">layers</span></code> dictionary, because it determines the final architecture of the model.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># initialization of the features in nodes and edges</span>
<span class="n">layers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;one_hot&quot;</span><span class="p">:</span> <span class="n">OneHotAtomEncoding</span><span class="p">,</span>
    <span class="s2">&quot;spharm_edges&quot;</span><span class="p">:</span> <span class="n">SphericalHarmonicEdgeAttrs</span><span class="p">,</span>
    <span class="s2">&quot;radial_basis&quot;</span><span class="p">:</span> <span class="n">RadialBasisEdgeEncoding</span><span class="p">,</span>
    <span class="s2">&quot;chemical_embedding&quot;</span><span class="p">:</span> <span class="n">AtomwiseLinear</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># add convnet layers</span>
<span class="k">for</span> <span class="n">layer_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_layers</span><span class="p">):</span>
    <span class="n">layers</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;layer</span><span class="si">{</span><span class="n">layer_i</span><span class="si">}</span><span class="s2">_convnet&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ConvNetLayer</span>

<span class="c1"># .update also maintains insertion order</span>
<span class="n">layers</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="c1"># -- output block --</span>
        <span class="s2">&quot;conv_to_output_hidden&quot;</span><span class="p">:</span> <span class="n">AtomwiseLinear</span><span class="p">,</span>
        <span class="s2">&quot;output_hidden_to_scalar&quot;</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">AtomwiseLinear</span><span class="p">,</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">irreps_out</span><span class="o">=</span><span class="s2">&quot;1x0e&quot;</span><span class="p">,</span> <span class="n">out_field</span><span class="o">=</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">PER_ATOM_ENERGY_KEY</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1"># global pooling</span>
<span class="n">layers</span><span class="p">[</span><span class="s2">&quot;total_energy_sum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">AtomwiseReduce</span><span class="p">,</span>
    <span class="nb">dict</span><span class="p">(</span>
        <span class="n">reduce</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span>
        <span class="n">field</span><span class="o">=</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">PER_ATOM_ENERGY_KEY</span><span class="p">,</span>
        <span class="n">out_field</span><span class="o">=</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">TOTAL_ENERGY_KEY</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>In next we will introduce each component in detail.</p>
</section>
<section id="initilization-of-the-features-in-nodes-and-edges">
<h3>Initilization of the features in nodes and edges<a class="headerlink" href="#initilization-of-the-features-in-nodes-and-edges" title="Link to this heading">#</a></h3>
<p>After we create the <strong>AtomicData</strong> object, the next step is to do the initialization of the features in nodes and edges. In the <strong>layers</strong> dictionary, we can see there are four functions: <strong>OneHotAtomEncoding</strong>, <strong>SphericalHarmonicEdgeAttrs</strong>, <strong>RadialBasisEdgeEncoding</strong>, <strong>AtomwiseLinear</strong>. We will introduce them one by one.</p>
<p><strong>OneHotAtomEncoding</strong> (<a class="reference external" href="https://github.com/mir-group/nequip/blob/main/nequip/nn/embedding/_one_hot.py">code_onehot</a>)</p>
<p>One hot encoding for each node <span class="math notranslate nohighlight">\(\vec{V}=\rm [0, 0, ..., 0, 1, 0, ..., 0]\in \mathbb{R}^{num\_elements}\)</span>, where <span class="math notranslate nohighlight">\(V_i=1\)</span> if <span class="math notranslate nohighlight">\(Z\)</span> (the atomic number of current atom) is the <span class="math notranslate nohighlight">\(i\)</span>-th element in the list of all atomic numbers in our training set.</p>
<p><strong>SphericalHarmonicEdgeAttrs</strong> (<a class="reference external" href="https://github.com/mir-group/nequip/blob/main/nequip/nn/embedding/_edge.py">code_spharm</a>)</p>
<p>Encoding for each edge. This uses the the <code class="code docutils literal notranslate"><span class="pre">e3nn.o3.SphericalHarmonics()</span></code> function to get the feature vector of edges up to a maximum rotation order <span class="math notranslate nohighlight">\(l_{\text{max}}\)</span>.</p>
<p><strong>RadialBasisEdgeEncoding</strong> (<a class="reference external" href="https://github.com/mir-group/nequip/blob/main/nequip/nn/embedding/_edge.py">code_radial</a>)</p>
<p>The radial distribution function in NequIP is defined as the summation of <code class="code docutils literal notranslate"><span class="pre">num_basis</span></code> Bessel functions. The parameters in the Bessel function are trainable.</p>
<p><strong>AtomwiseLinear</strong> (<a class="reference external" href="https://github.com/mir-group/nequip/blob/main/nequip/nn/_atomwise.py">code_linear</a>)</p>
<p>This is a linear layer transforms the irreducible representation from the input to the output. The number of parameters depends on the legnth of the input and output irreps.</p>
</section>
<section id="convolutional-layers">
<h3>Convolutional Layers<a class="headerlink" href="#convolutional-layers" title="Link to this heading">#</a></h3>
<p>There are some discrepencies on the naming convention between the original paper and the code. In the original paper, they have used <strong>Interaction Block</strong> in the architecture (shown in <a class="reference internal" href="#nequip-energy"><span class="std std-numref">Fig. 3</span></a>), but in the code it is implemented as <strong>Convolutional Layer</strong> (see <a class="reference external" href="https://github.com/mir-group/nequip/blob/main/nequip/nn/_convnetlayer.py">source code</a>). And the <strong>Interaction Block</strong> is inside the convolutional layer.</p>
<div class="admonition-interaction-block-in-convolutional-layer admonition">
<p class="admonition-title">Interaction block in convolutional layer</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ConvNetLayer</span><span class="p">(</span><span class="n">GraphModuleMixin</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(:</span>
        <span class="c1"># ... (code)</span>
        <span class="n">convolution</span><span class="o">=</span><span class="n">InteractionBlock</span><span class="p">,</span> <span class="c1"># this is the Interaction Block</span>
        <span class="c1"># ... (code)</span>
    <span class="p">):</span>
</pre></div>
</div>
</div>
<p>For each convolutional layer, we performs a resnet-like update of the node features. The code for the convolutional layer is written as below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ConvNetLayer</span><span class="p">(</span><span class="n">GraphModuleMixin</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">Type</span><span class="p">:</span>
        <span class="c1"># save old features for resnet</span>
        <span class="n">old_x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span>
        <span class="c1"># run convolution</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># do nonlinearity</span>
        <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivariant_nonlin</span><span class="p">(</span>
            <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># do resnet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resnet</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">old_x</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>From the code above, in each convolutional layer, we have two steps:</p>
<ol class="arabic simple">
<li><p>Convolution: This is the Interaction Block, which performs the convolution between nodes and edges.</p></li>
<li><p>Nonlinearity: This is the equivariant non-linearity, which is applied to the node features after the convolution.</p></li>
</ol>
<p>Next we will focus on the convolution part, which is the <code class="code docutils literal notranslate"><span class="pre">InteractionBlock</span></code> in the code.</p>
<p>The architecture of the <code class="code docutils literal notranslate"><span class="pre">InteractionBlock</span></code> is shown in <a class="reference internal" href="#interaction-block"><span class="std std-numref">Fig. 4</span></a>.</p>
<figure class="align-center" id="id3">
<span id="interaction-block"></span><a class="reference internal image-reference" href="../_images/interaction_block.png"><img alt="../_images/interaction_block.png" src="../_images/interaction_block.png" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Architecture of the Interaction Block in NequIP. The red boxes represent the naming in the code.</span><a class="headerlink" href="#id3" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The definition of each component is defined in <code class="code docutils literal notranslate"><span class="pre">__init__()</span></code> function, and the structure of the <code class="code docutils literal notranslate"><span class="pre">InteractionBlock</span></code> is defined in <code class="code docutils literal notranslate"><span class="pre">forward()</span></code> function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InteractionBlock</span><span class="p">(</span><span class="n">GraphModuleMixin</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="n">invariant_layers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">invariant_neurons</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_1</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="n">feature_irreps_in</span><span class="p">,</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="n">feature_irreps_in</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">tp</span> <span class="o">=</span> <span class="n">TensorProduct</span><span class="p">(</span>
            <span class="n">feature_irreps_in</span><span class="p">,</span>
            <span class="n">irreps_edge_attr</span><span class="p">,</span>
            <span class="n">irreps_mid</span><span class="p">,</span>
            <span class="n">instructions</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tp</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">FullyConnectedNet</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_EMBEDDING_KEY</span><span class="p">]</span><span class="o">.</span><span class="n">num_irreps</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">invariant_layers</span> <span class="o">*</span> <span class="p">[</span><span class="n">invariant_neurons</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">weight_numel</span><span class="p">],</span>
            <span class="p">{</span>
                <span class="s2">&quot;ssp&quot;</span><span class="p">:</span> <span class="n">ShiftedSoftPlus</span><span class="p">,</span>
                <span class="s2">&quot;silu&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">silu</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">nonlinearity_scalars</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">]],</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">linear_2</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span>
            <span class="n">irreps_in</span><span class="o">=</span><span class="n">irreps_mid</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span>
            <span class="n">irreps_out</span><span class="o">=</span><span class="n">feature_irreps_out</span><span class="p">,</span>
            <span class="n">internal_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shared_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_sc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="o">=</span> <span class="n">FullyConnectedTensorProduct</span><span class="p">(</span>
                <span class="n">feature_irreps_in</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_ATTRS_KEY</span><span class="p">],</span>
                <span class="n">feature_irreps_out</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">Type</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_EMBEDDING_KEY</span><span class="p">])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span>
        <span class="n">edge_src</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_INDEX_KEY</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">edge_dst</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_INDEX_KEY</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_ATTRS_KEY</span><span class="p">])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">edge_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">(</span>
            <span class="n">x</span><span class="p">[</span><span class="n">edge_src</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">EDGE_ATTRS_KEY</span><span class="p">],</span> <span class="n">weight</span>
        <span class="p">)</span>
        <span class="c1"># divide first for numerics, scatter is linear</span>
        <span class="c1"># Necessary to get TorchScript to be able to type infer when its not None</span>
        <span class="n">avg_num_neigh</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_num_neighbors</span>
        <span class="k">if</span> <span class="n">avg_num_neigh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_features</span> <span class="o">=</span> <span class="n">edge_features</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">avg_num_neigh</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="c1"># now scatter down</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">scatter</span><span class="p">(</span><span class="n">edge_features</span><span class="p">,</span> <span class="n">edge_dst</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim_size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sc</span>

        <span class="n">data</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_FEATURES_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>From the last step in the <code class="code docutils literal notranslate"><span class="pre">forward()</span></code> function, the node features are updated by: <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">sc</span></code>. The <code class="code docutils literal notranslate"><span class="pre">sc</span></code> corresponds to the left path of <a class="reference internal" href="#interaction-block"><span class="std std-numref">Fig. 4</span></a>, and <code class="code docutils literal notranslate"><span class="pre">x</span></code> corresponds to the right path.</p>
<p>The code for calculating <code class="code docutils literal notranslate"><span class="pre">sc</span></code> is written as below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="o">=</span> <span class="n">FullyConnectedTensorProduct</span><span class="p">(</span>
    <span class="n">feature_irreps_in</span><span class="p">,</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">irreps_in</span><span class="p">[</span><span class="n">AtomicDataDict</span><span class="o">.</span><span class="n">NODE_ATTRS_KEY</span><span class="p">],</span>
    <span class="n">feature_irreps_out</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">AtomicDataDict.NODE_ATTRS_KEY</span></code> represents the attributes of nodes, which is the atomic number of each atom.</p>
<p>The calculation of <code class="code docutils literal notranslate"><span class="pre">x</span></code> through the right path involves four main steps:</p>
<ol class="arabic simple">
<li><p>Linear transformation: <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">self.linear_1(x)</span></code></p></li>
<li><p>Tensor product with edge attributes: <code class="code docutils literal notranslate"><span class="pre">edge_features</span> <span class="pre">=</span> <span class="pre">self.tp(x[edge_src],</span> <span class="pre">data[AtomicDataDict.EDGE_ATTRS_KEY],</span> <span class="pre">weight)</span></code>,  and then do the normalization based on the coordination number (if applicable): <code class="code docutils literal notranslate"><span class="pre">edge_features</span> <span class="pre">=</span> <span class="pre">edge_features.div(avg_num_neigh**0.5)</span></code></p></li>
<li><p>Scatter and aggregation: <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">scatter(edge_features,</span> <span class="pre">edge_dst,</span> <span class="pre">dim=0,</span> <span class="pre">dim_size=len(x))</span></code></p></li>
<li><p>At last, a second linear transformation is applied: <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">self.linear_2(x)</span></code></p></li>
</ol>
<p>These steps correspond to the operations shown in the right path of the interaction block diagram.</p>
<p>After we get <code class="code docutils literal notranslate"><span class="pre">sc</span></code> from left path and <code class="code docutils literal notranslate"><span class="pre">x</span></code> from right path, we add them together, do a nonlinearity (<code class="code docutils literal notranslate"><span class="pre">equivariant_nonlin()</span></code>) and then updated node features in a resnet-like fashion.</p>
</section>
<section id="feed-forward-network-and-global-pooling">
<h3>Feed-forward network and global pooling<a class="headerlink" href="#feed-forward-network-and-global-pooling" title="Link to this heading">#</a></h3>
<p>After the last convolutional layer, we only choose the scalar part of the node feature vector, which has length of <code class="code docutils literal notranslate"><span class="pre">num_features</span></code>, then we apply two linear layers to get the final output. The first linear layer transforms <span class="math notranslate nohighlight">\(\rm \mathbb{R}^{num\_features}\rightarrow \rm \mathbb{R}^{num\_features/2}\)</span>, and the second linear layer transforms <span class="math notranslate nohighlight">\(\rm \mathbb{R}^{num\_features/2}\rightarrow \rm \mathbb{R}^{1}\)</span>, which is the final ennergy of each atom.</p>
<p>After the atom-wise operations, we perform global pooling to get the total energy of the system. The global pooling is performed by <code class="code docutils literal notranslate"><span class="pre">AtomwiseReduce</span></code> with <code class="code docutils literal notranslate"><span class="pre">reduce=&quot;sum&quot;</span></code> and <code class="code docutils literal notranslate"><span class="pre">field=AtomicDataDict.PER_ATOM_ENERGY_KEY</span></code> and <code class="code docutils literal notranslate"><span class="pre">out_field=AtomicDataDict.TOTAL_ENERGY_KEY</span></code>.</p>
<p>Next, we can use the total energy to calculate the forces by doing the derivative of the energy with respect to the atomic positions. Then the loss function is the mean squared error between the predicted forces and the true forces plus the mean squared error between the predicted total energy and the true total energy. With the loss function, we can use the gradient descent method to update the parameters in the model.</p>
</section>
</section>
<section id="check-equivariance-of-the-energy-model">
<h2>Check equivariance of the energy model<a class="headerlink" href="#check-equivariance-of-the-energy-model" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Since in NequIP model we only consider the distance between atoms, the radial distribution function is invariant to the translation operation.</p></li>
<li><p>Since in NequIP model we do summation on the local atomic environments, the energy model is invariant to the permutation of atoms.</p></li>
<li><p>Since NequIP model uses the rotation order to expand the distance between atoms, the energy model is equivariant to the rotation operation.</p></li>
</ul>
<p>This guarantees the equivariance of the energy model in <span class="math notranslate nohighlight">\(\rm E(3)\)</span> group (combination of translation, rotation, reflection and inversion).</p>
</section>
<section id="several-nice-talks-about-the-theory-of-nequip">
<h2>Several nice talks about the theory of NequIP<a class="headerlink" href="#several-nice-talks-about-the-theory-of-nequip" title="Link to this heading">#</a></h2>
<div class="admonition-nequip-talk-at-valence-lab admonition">
<p class="admonition-title">NequIP talk at Valence Lab</p>
<div class="video_wrapper align-center" style="text-align: center">
<iframe allowfullscreen="true" src="https://www.youtube.com/embed/ZR1NTBPBDOo" style="border: 0; height: 367px; width: 600px">
</iframe></div></div>
<div class="admonition-allegro-talk-at-valence-lab admonition">
<p class="admonition-title">Allegro talk at Valence Lab</p>
<div class="video_wrapper align-center" style="text-align: center">
<iframe allowfullscreen="true" src="https://www.youtube.com/embed/-mRl5Uk8IWk" style="border: 0; height: 367px; width: 600px">
</iframe></div></div>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="NequIP.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">NequIP</p>
      </div>
    </a>
    <a class="right-next"
       href="NequIP_practice.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Practical use of NequIP</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-foundation-of-nequip">Mathematical foundation of NequIP</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#build-a-nequip-network-from-scratch">Build a NequIP network from scratch</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#architecture-of-energy-model-in-nequip">Architecture of energy model in NequIP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#initilization-of-the-features-in-nodes-and-edges">Initilization of the features in nodes and edges</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#convolutional-layers">Convolutional Layers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#feed-forward-network-and-global-pooling">Feed-forward network and global pooling</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#check-equivariance-of-the-energy-model">Check equivariance of the energy model</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#several-nice-talks-about-the-theory-of-nequip">Several nice talks about the theory of NequIP</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Zhengda He
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, Zhengda He.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>